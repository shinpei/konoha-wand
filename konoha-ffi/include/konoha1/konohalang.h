// THIS FILE WAS AUTOMATICALLY GENERATED

#ifndef MN_OPSIZE
#define STT_MAX  (56)
#define TT_MAX   (139)
#define MN_OPSIZE  (31)
#define MN_opNOT                        ((knh_methodn_t)0)
#define MN_opEXISTS                     ((knh_methodn_t)1)
#define MN_opTO                         ((knh_methodn_t)2)
#define MN_opUNTIL                      ((knh_methodn_t)3)
#define MN_opIS                         ((knh_methodn_t)4)
#define MN_opOF                         ((knh_methodn_t)5)
#define MN_opHAS                        ((knh_methodn_t)6)
#define MN_opEQ                         ((knh_methodn_t)7)
#define MN_opNOTEQ                      ((knh_methodn_t)8)
#define MN_opLT                         ((knh_methodn_t)9)
#define MN_opLTE                        ((knh_methodn_t)10)
#define MN_opGT                         ((knh_methodn_t)11)
#define MN_opGTE                        ((knh_methodn_t)12)
#define MN_opLOR                        ((knh_methodn_t)13)
#define MN_opLXOR                       ((knh_methodn_t)14)
#define MN_opLAND                       ((knh_methodn_t)15)
#define MN_opADD                        ((knh_methodn_t)16)
#define MN_opSUB                        ((knh_methodn_t)17)
#define MN_opDIV                        ((knh_methodn_t)18)
#define MN_opMOD                        ((knh_methodn_t)19)
#define MN_opMUL                        ((knh_methodn_t)20)
#define MN_opLSFT                       ((knh_methodn_t)21)
#define MN_opRSFT                       ((knh_methodn_t)22)
#define MN_opLNOT                       ((knh_methodn_t)23)
#define MN_opNEXT                       ((knh_methodn_t)24)
#define MN_opPREV                       ((knh_methodn_t)25)
#define MN_opITR                        ((knh_methodn_t)26)
#define MN_opADDR                       ((knh_methodn_t)27)
#define MN_opCAST                       ((knh_methodn_t)28)
#define MN_opPLUS                       ((knh_methodn_t)29)
#define MN_opNEG                        ((knh_methodn_t)30)

/* ------------------------------------------------------------------------ */

#define STT_DONE  ((knh_term_t)0)
#define STT_BLOCK  ((knh_term_t)1)
#define STT_PRAGMA  ((knh_term_t)2)
#define STT_NAMESPACE  ((knh_term_t)3)
#define STT_SCRIPT  ((knh_term_t)4)
#define STT_DEFMACRO  ((knh_term_t)5)
#define STT_INCLUDE  ((knh_term_t)6)
#define STT_ALLOW  ((knh_term_t)7)
#define STT_DENY  ((knh_term_t)8)
#define STT_USING  ((knh_term_t)9)
#define STT_CLASS  ((knh_term_t)10)
#define STT_FORMAT  ((knh_term_t)11)
#define STT_RETURN  ((knh_term_t)12)
#define STT_YIELD  ((knh_term_t)13)
#define STT_IF  ((knh_term_t)14)
#define STT_SWITCH  ((knh_term_t)15)
#define STT_CASE  ((knh_term_t)16)
#define STT_WHILE  ((knh_term_t)17)
#define STT_DO  ((knh_term_t)18)
#define STT_FOR  ((knh_term_t)19)
#define STT_FOREACH  ((knh_term_t)20)
#define STT_BREAK  ((knh_term_t)21)
#define STT_CONTINUE  ((knh_term_t)22)
#define STT_TRY  ((knh_term_t)23)
#define STT_CATCH  ((knh_term_t)24)
#define STT_THROW  ((knh_term_t)25)
#define STT_PRINT  ((knh_term_t)26)
#define STT_ASSURE  ((knh_term_t)27)
#define STT_ASSERT  ((knh_term_t)28)
#define STT_REGISTER  ((knh_term_t)29)
#define STT_FUNCTION  ((knh_term_t)30)
#define STT_METHOD  ((knh_term_t)31)
#define STT_DECL  ((knh_term_t)32)
#define STT_CHKOUT  ((knh_term_t)33)
#define STT_LETM  ((knh_term_t)34)
#define STT_SWAP  ((knh_term_t)35)
#define STT_CONST  ((knh_term_t)36)
#define STT_ERR  ((knh_term_t)37)
#define STT_LET  ((knh_term_t)38)
#define STT_TCAST  ((knh_term_t)39)
#define STT_BOX  ((knh_term_t)40)
#define STT_OPR  ((knh_term_t)41)
#define STT_CALL  ((knh_term_t)42)
#define STT_NEW  ((knh_term_t)43)
#define STT_FUNCCALL  ((knh_term_t)44)
#define STT_ACALL  ((knh_term_t)45)
#define STT_TLINK  ((knh_term_t)46)
#define STT_ALT  ((knh_term_t)47)
#define STT_TRI  ((knh_term_t)48)
#define STT_AND  ((knh_term_t)49)
#define STT_OR  ((knh_term_t)50)
#define STT_W1  ((knh_term_t)51)
#define STT_SEND  ((knh_term_t)52)
#define STT_FMTCALL  ((knh_term_t)53)
#define STT_CALL1  ((knh_term_t)54)
#define STT_GO  ((knh_term_t)55)
#define TT_PRAGMA   ((knh_term_t)56)
#define TT_NAMESPACE   ((knh_term_t)57)
#define TT_SCRIPT   ((knh_term_t)58)
#define TT_INCLUDE   ((knh_term_t)59)
#define TT_IMPORT   ((knh_term_t)60)
#define TT_USING   ((knh_term_t)61)
#define TT_CLASS   ((knh_term_t)62)
#define TT_FORMAT   ((knh_term_t)63)
#define TT_RETURN   ((knh_term_t)64)
#define TT_YIELD   ((knh_term_t)65)
#define TT_IF   ((knh_term_t)66)
#define TT_SWITCH   ((knh_term_t)67)
#define TT_CASE   ((knh_term_t)68)
#define TT_WHILE   ((knh_term_t)69)
#define TT_DO   ((knh_term_t)70)
#define TT_FOR   ((knh_term_t)71)
#define TT_FOREACH   ((knh_term_t)72)
#define TT_BREAK   ((knh_term_t)73)
#define TT_CONTINUE   ((knh_term_t)74)
#define TT_GOTO   ((knh_term_t)75)
#define TT_TRY   ((knh_term_t)76)
#define TT_CATCH   ((knh_term_t)77)
#define TT_THROW   ((knh_term_t)78)
#define TT_PRINT   ((knh_term_t)79)
#define TT_ASSURE   ((knh_term_t)80)
#define TT_ASSERT   ((knh_term_t)81)
#define TT_REGISTER   ((knh_term_t)82)
#define TT_GO   ((knh_term_t)83)
#define TT_EXTENDS   ((knh_term_t)84)
#define TT_IMPLEMENTS   ((knh_term_t)85)
#define TT_ELSE   ((knh_term_t)86)
#define TT_DEFAULT   ((knh_term_t)87)
#define TT_FINALLY   ((knh_term_t)88)
#define TT_SEMICOLON   ((knh_term_t)89)
#define TT_COMMA   ((knh_term_t)90)
#define TT_DIAMOND   ((knh_term_t)91)
#define TT_ARROW   ((knh_term_t)92)
#define TT_DARROW   ((knh_term_t)93)
#define TT_TARROW   ((knh_term_t)94)
#define TT_TDARROW   ((knh_term_t)95)
#define TT_EXPT   ((knh_term_t)96)
#define TT_LSEND   ((knh_term_t)97)
#define TT_RSEND   ((knh_term_t)98)
#define TT_DOTS   ((knh_term_t)99)
#define TT_DMUL   ((knh_term_t)100)
#define TT_ASIS   ((knh_term_t)101)
#define TT_FUNCTION   ((knh_term_t)102)
#define TT_NEW   ((knh_term_t)103)
#define TT_NULL   ((knh_term_t)104)
#define TT_TYPEOF   ((knh_term_t)105)
#define TT_VOID   ((knh_term_t)106)
#define TT_VAR   ((knh_term_t)107)
#define TT_BYTE   ((knh_term_t)108)
#define TT_DYN   ((knh_term_t)109)
#define TT_TRUE   ((knh_term_t)110)
#define TT_FALSE   ((knh_term_t)111)
#define TT_BRACE   ((knh_term_t)112)
#define TT_PARENTHESIS   ((knh_term_t)113)
#define TT_BRANCET   ((knh_term_t)114)
#define TT_DECLLET   ((knh_term_t)115)
#define TT_LSFTE   ((knh_term_t)116)
#define TT_RSFTE   ((knh_term_t)117)
#define TT_ADDE   ((knh_term_t)118)
#define TT_SUBE   ((knh_term_t)119)
#define TT_DIVE   ((knh_term_t)120)
#define TT_MODE   ((knh_term_t)121)
#define TT_MULE   ((knh_term_t)122)
#define TT_LANDE   ((knh_term_t)123)
#define TT_LORE   ((knh_term_t)124)
#define TT_ALTLET   ((knh_term_t)125)
#define TT_LET   ((knh_term_t)126)
#define TT_ALT   ((knh_term_t)127)
#define TT_QTN   ((knh_term_t)128)
#define TT_COLON   ((knh_term_t)129)
#define TT_DOT   ((knh_term_t)130)
#define TT_OR   ((knh_term_t)131)
#define TT_AND   ((knh_term_t)132)
#define TT_NOT   ((knh_term_t)133)
#define TT_EXISTS   ((knh_term_t)134)
#define TT_FROM   ((knh_term_t)135)
#define TT_TO   ((knh_term_t)136)
#define TT_AS   ((knh_term_t)137)
#define TT_UNTIL   ((knh_term_t)138)
#define TT_IS   ((knh_term_t)139)
#define TT_OF   ((knh_term_t)140)
#define TT_IN   ((knh_term_t)141)
#define TT_EQ   ((knh_term_t)142)
#define TT_NEQ   ((knh_term_t)143)
#define TT_LT   ((knh_term_t)144)
#define TT_LTE   ((knh_term_t)145)
#define TT_GT   ((knh_term_t)146)
#define TT_GTE   ((knh_term_t)147)
#define TT_LOR   ((knh_term_t)148)
#define TT_XOR   ((knh_term_t)149)
#define TT_LAND   ((knh_term_t)150)
#define TT_ADD   ((knh_term_t)151)
#define TT_SUB   ((knh_term_t)152)
#define TT_DIV   ((knh_term_t)153)
#define TT_MOD   ((knh_term_t)154)
#define TT_MUL   ((knh_term_t)155)
#define TT_LSFT   ((knh_term_t)156)
#define TT_RSFT   ((knh_term_t)157)
#define TT_LNOT   ((knh_term_t)158)
#define TT_NEXT   ((knh_term_t)159)
#define TT_PREV   ((knh_term_t)160)
#define TT_ITR   ((knh_term_t)161)
#define TT_TAND   ((knh_term_t)162)
#define TT_TMUL   ((knh_term_t)163)
#define TT_TADD   ((knh_term_t)164)
#define TT_TSUB   ((knh_term_t)165)
#define TT_CODE   ((knh_term_t)166)
#define TT_DOCU   ((knh_term_t)167)
#define TT_NUM   ((knh_term_t)168)
#define TT_STR   ((knh_term_t)169)
#define TT_TSTR   ((knh_term_t)170)
#define TT_ESTR   ((knh_term_t)171)
#define TT_REGEX   ((knh_term_t)172)
#define TT_DOC   ((knh_term_t)173)
#define TT_METAN   ((knh_term_t)174)
#define TT_PROPN   ((knh_term_t)175)
#define TT_URN   ((knh_term_t)176)
#define TT_TLINK   ((knh_term_t)177)
#define TT_NAME   ((knh_term_t)178)
#define TT_UNAME   ((knh_term_t)179)
#define TT_FUNCNAME   ((knh_term_t)180)
#define TT_UFUNCNAME   ((knh_term_t)181)
#define TT_PTYPE   ((knh_term_t)182)
#define TT_CID   ((knh_term_t)183)
#define TT_MN   ((knh_term_t)184)
#define TT_FMT   ((knh_term_t)185)
#define TT_CONST   ((knh_term_t)186)
#define TT_SYSVAL   ((knh_term_t)187)
#define TT_LOCAL   ((knh_term_t)188)
#define TT_FUNCVAR   ((knh_term_t)189)
#define TT_XLOCAL   ((knh_term_t)190)
#define TT_FIELD   ((knh_term_t)191)
#define TT_SCRFIELD   ((knh_term_t)192)
#define TT_ERR   ((knh_term_t)193)
#define TT_EOT   ((knh_term_t)194)
#endif/*MN_OPSIZE*/


#ifdef K_USING_LOADDATA

typedef struct {
	const char *name;
	knh_flag_t  flag;
	knh_short_t to;
} TERMDATA_t;

#define _BIN 1

static TERMDATA_t TERMDATA[] = {
	{"DONE", 0, -1}, 
	{"BLOCK", 0, -1}, 
	{"pragma", 0, -1}, 
	{"namespace", 0, -1}, 
	{"script", 0, -1}, 
	{"defmacro", 0, -1}, 
	{"include", 0, -1}, 
	{"allow", 0, -1}, 
	{"deny", 0, -1}, 
	{"using", 0, -1}, 
	{"class", 0, -1}, 
	{"format", 0, -1}, 
	{"return", 0, -1}, 
	{"yield", 0, -1}, 
	{"if", 0, -1}, 
	{"switch", 0, -1}, 
	{"case", 0, -1}, 
	{"while", 0, -1}, 
	{"do", 0, -1}, 
	{"for", 0, -1}, 
	{"foreach", 0, -1}, 
	{"break", 0, -1}, 
	{"continue", 0, -1}, 
	{"try", 0, -1}, 
	{"catch", 0, -1}, 
	{"throw", 0, -1}, 
	{"print", 0, -1}, 
	{"assure", 0, -1}, 
	{"assert", 0, -1}, 
	{"register", 0, -1}, 
	{"function", 0, -1}, 
	{"METHOD", 0, -1}, 
	{"DECL", 0, -1}, 
	{"CHKOUT", 0, -1}, 
	{"LETM", 0, -1}, 
	{"SWAP", 0, -1}, 
	{"CONST", 0, -1}, 
	{"ERR", 0, -1}, 
	{"LET", 0, -1}, 
	{"TCAST", 0, -1}, 
	{"BOX", 0, -1}, 
	{"OPR", 0, -1}, 
	{"CALL", 0, -1}, 
	{"NEW", 0, -1}, 
	{"FUNCCALL", 0, -1}, 
	{"ACALL", 0, -1}, 
	{"TLINK", 0, -1}, 
	{"ALT", 0, -1}, 
	{"TRI", 0, -1}, 
	{"AND", 0, -1}, 
	{"OR", 0, -1}, 
	{"W1", 0, -1}, 
	{"SEND", 0, -1}, 
	{"FMTCALL", 0, -1}, 
	{"CALL1", 0, -1}, 
	{"*go", 0, -1}, 
	{"pragma", 0, STT_PRAGMA}, 
	{"namespace", 0, STT_NAMESPACE}, 
	{"script", 0, STT_SCRIPT}, 
	{"include", 0, STT_INCLUDE}, 
	{"import", 0, -1}, 
	{"using", 0, STT_USING}, 
	{"class", 0, STT_CLASS}, 
	{"format", 0, STT_FORMAT}, 
	{"return", 0, STT_RETURN}, 
	{"yield", 0, STT_YIELD}, 
	{"if", 0, STT_IF}, 
	{"switch", 0, STT_SWITCH}, 
	{"case", 0, STT_CASE}, 
	{"while", 0, STT_WHILE}, 
	{"do", 0, STT_DO}, 
	{"for", 0, STT_FOR}, 
	{"foreach", 0, STT_FOREACH}, 
	{"break", 0, STT_BREAK}, 
	{"continue", 0, STT_CONTINUE}, 
	{"goto", 0, -1}, 
	{"try", 0, STT_TRY}, 
	{"catch", 0, STT_CATCH}, 
	{"throw", 0, STT_THROW}, 
	{"print", 0, STT_PRINT}, 
	{"assure", 0, STT_ASSURE}, 
	{"assert", 0, STT_ASSERT}, 
	{"register", 0, STT_REGISTER}, 
	{"go", 0, STT_GO}, 
	{"extends", 0, -1}, 
	{"implements", 0, -1}, 
	{"else", 0, -1}, 
	{"default", 0, -1}, 
	{"finally", 0, -1}, 
	{";", 0, -1}, 
	{",", 0, -1}, 
	{"<>", 0, -1}, 
	{"->", 0, -1}, 
	{"=>", 0, -1}, 
	{"-->", 0, -1}, 
	{"==>", 0, -1}, 
	{"!!", 0, -1}, 
	{"<<<", 0, -1}, 
	{">>>", 0, -1}, 
	{"...", 0, -1}, 
	{"**", 0, -1}, 
	{"_", 0, -1}, 
	{"function", 0, STT_FUNCTION}, 
	{"new", 0, -1}, 
	{"null", 0, -1}, 
	{"typeof", 0, -1}, 
	{"void", 0, -1}, 
	{"var", 0, -1}, 
	{"byte", 0, -1}, 
	{"dyn", 0, -1}, 
	{"true", 0, -1}, 
	{"false", 0, -1}, 
	{"{", 0, -1}, 
	{"(", 0, -1}, 
	{"[", 0, -1}, 
	{":=", 0, -1}, 
	{"<<=", 0, TT_LSFT}, 
	{">>=", 0, TT_RSFT}, 
	{"+=", 0, TT_ADD}, 
	{"-=", 0, TT_SUB}, 
	{"/=", 0, TT_DIV}, 
	{"%=", 0, TT_MOD}, 
	{"*=", 0, TT_MUL}, 
	{"&=", 0, TT_LAND}, 
	{"|=", 0, TT_LOR}, 
	{"?\?=", 0, TT_ALT}, 
	{"=", 0, MN_NONAME}, 
	{"?\?", 0, MN_NONAME}, 
	{"?", 0, MN_NONAME}, 
	{":", 0, MN_NONAME}, 
	{".", 0, MN_NONAME}, 
	{"or", 0, MN_NONAME}, 
	{"and", 0, MN_NONAME}, 
	{"not", 0, MN_opNOT}, 
	{"exists", 0, MN_opEXISTS}, 
	{"from", 0, MN_NONAME}, 
	{"to", 0, MN_opTO}, 
	{"as", 0, MN_NONAME}, 
	{"until", 0, MN_opUNTIL}, 
	{"is?", _BIN, MN_opIS}, 
	{"<:", _BIN, MN_opOF}, 
	{"in?", _BIN, MN_opHAS}, 
	{"==", _BIN, MN_opEQ}, 
	{"!=", _BIN, MN_opNOTEQ}, 
	{"<", _BIN, MN_opLT}, 
	{"<=", _BIN, MN_opLTE}, 
	{">", _BIN, MN_opGT}, 
	{">=", _BIN, MN_opGTE}, 
	{"|", _BIN, MN_opLOR}, 
	{"^", _BIN, MN_opLXOR}, 
	{"&", _BIN, MN_opLAND}, 
	{"+", _BIN, MN_opADD}, 
	{"-", _BIN, MN_opSUB}, 
	{"/", _BIN, MN_opDIV}, 
	{"%", _BIN, MN_opMOD}, 
	{"*", _BIN, MN_opMUL}, 
	{"<<", _BIN, MN_opLSFT}, 
	{">>", _BIN, MN_opRSFT}, 
	{"~", 0, MN_opLNOT}, 
	{"++", 0, MN_opNEXT}, 
	{"--", 0, MN_opPREV}, 
	{"..", 0, MN_opITR}, 
	{"&&&", 0, MN_opADDR}, 
	{"***", 0, MN_opCAST}, 
	{"+++", 0, MN_opPLUS}, 
	{"---", 0, MN_opNEG}, 
	{"CODE", 0, -1}, 
	{"DOCU", 0, -1}, 
	{"NUM", 0, -1}, 
	{"STR", 0, -1}, 
	{"TSTR", 0, -1}, 
	{"ESTR", 0, -1}, 
	{"REGEX", 0, -1}, 
	{"DOC", 0, -1}, 
	{"METAN", 0, -1}, 
	{"PROPN", 0, -1}, 
	{"URN", 0, -1}, 
	{"TLINK", 0, -1}, 
	{"NAME", 0, -1}, 
	{"UNAME", 0, -1}, 
	{"FUNCNAME", 0, -1}, 
	{"UFUNCNAME", 0, -1}, 
	{"PTYPE", 0, -1}, 
	{"CID", 0, -1}, 
	{"MN", 0, -1}, 
	{"FMT", 0, -1}, 
	{"CONST", 0, -1}, 
	{"SYSVAL", 0, -1}, 
	{"LOCAL", 0, -1}, 
	{"FUNCVAR", 0, -1}, 
	{"XLOCAL", 0, -1}, 
	{"FIELD", 0, -1}, 
	{"SCRFIELD", 0, -1}, 
	{"ERR", 0, -1}, 
	{"EOT", 0, -1}, 
	{NULL, 0, 0}
};

static void knh_loadScriptTokenData(CTX ctx)
{
	knh_DictSet_t *ds = DP(ctx->sys)->tokenDictSet;
	TERMDATA_t *data = TERMDATA + STT_MAX;
	int tt = STT_MAX;
	while(data->name != NULL) {
		if(!isupper(data->name[0])) {
			knh_DictSet_append(ctx, ds, new_T(data->name), tt);
		}
		tt++;
		data++;
	}
	knh_DictSet_sort(ctx, ds);
}

const char *TT__(knh_term_t tt)
{
	if(tt < TT_MAX + STT_MAX) {
		return TERMDATA[tt].name;
	}
	DBG_P("tt=%d", tt);
	return "UNDEFINED";
}

knh_bool_t TT_is(knh_term_t tt, knh_flag_t flag)
{
	return FLAG_is(TERMDATA[tt].flag, flag);
}

knh_short_t TT_to(knh_term_t tt)
{
	return TERMDATA[tt].to;
}

void knh_dumpKeyword(CTX ctx, knh_OutputStream_t *w)
{
	TERMDATA_t *data = TERMDATA + STT_MAX;
	while(data->name != NULL) {
		if(islower(data->name[0])) {
			knh_write_ascii(ctx, w, data->name);
			knh_putc(ctx, w, ' ');
		}
		data++;
	}
	knh_write_EOL(ctx, w);
}

typedef struct {
	const char *name;
	const char *alias;
} ALIASDATA_t;

static ALIASDATA_t __AliasData[] = {
	{"!", "not"}, 
	{"&&", "and"}, 
	{"===", "is"}, 
	{"ArrayList", "Array"}, 
	{"FALSE", "false"}, 
	{"False", "false"}, 
	{"Integer", "Int"}, 
	{"NULL", "null"}, 
	{"TRUE", "true"}, 
	{"True", "true"}, 
	{"boolean", "Boolean"}, 
	{"char", "Int"}, 
	{"const", "@Const"}, 
	{"def", "function"}, 
	{"double", "Float"}, 
	{"final", "@Final"}, 
	{"float", "Float"}, 
	{"instanceof", "<:"}, 
	{"int", "Int"}, 
	{"long", "Int"}, 
	{"mod", "%"}, 
	{"private", "@Private"}, 
	{"public", "@Public"}, 
	{"short", "Int"}, 
	{"static", "@Static"}, 
	{"string", "String"}, 
	{"virtual", "@Virtual"}, 
	{"||", "or"}, 
	{NULL, NULL}
};

void knh_loadScriptAliasTokenData(CTX ctx)
{
	ALIASDATA_t *data = __AliasData;
	knh_DictMap_t *dm = new_DictMap0(ctx, sizeof(__AliasData), 0/*isCaseMap*/, "AliasDictMap");
	KNH_INITv(ctx->wshare->sysAliasDictMapNULL, dm);
	while(data->name != NULL) {
		knh_DictMap_append(ctx, dm, new_T(data->name), UPCAST(new_T(data->alias)));
		data++;
	}
}

typedef struct { 
	knh_ushort_t priority;
	knh_methodn_t mn;
} OPDATA_t;

static OPDATA_t OPDATA[] = {
	{2, MN_NONAME}, /* = */
	{4, MN_NONAME}, /* ?\? */
	{4, MN_NONAME}, /* ? */
	{99, MN_NONAME}, /* : */
	{99, MN_NONAME}, /* . */
	{5, MN_NONAME}, /* or */
	{6, MN_NONAME}, /* and */
	{7, MN_opNOT}, /* not */
	{7, MN_opEXISTS}, /* exists */
	{7, MN_NONAME}, /* from */
	{7, MN_opTO}, /* to */
	{7, MN_NONAME}, /* as */
	{7, MN_opUNTIL}, /* until */
	{10, MN_opIS}, /* is? */
	{10, MN_opOF}, /* <: */
	{10, MN_opHAS}, /* in? */
	{10, MN_opEQ}, /* == */
	{10, MN_opNOTEQ}, /* != */
	{10, MN_opLT}, /* < */
	{10, MN_opLTE}, /* <= */
	{10, MN_opGT}, /* > */
	{10, MN_opGTE}, /* >= */
	{14, MN_opLOR}, /* | */
	{16, MN_opLXOR}, /* ^ */
	{18, MN_opLAND}, /* & */
	{20, MN_opADD}, /* + */
	{20, MN_opSUB}, /* - */
	{25, MN_opDIV}, /* / */
	{25, MN_opMOD}, /* % */
	{25, MN_opMUL}, /* * */
	{35, MN_opLSFT}, /* << */
	{35, MN_opRSFT}, /* >> */
	{40, MN_opLNOT}, /* ~ */
	{40, MN_opNEXT}, /* ++ */
	{40, MN_opPREV}, /* -- */
	{40, MN_opITR}, /* .. */
	{40, MN_opADDR}, /* &&& */
	{40, MN_opCAST}, /* *** */
	{40, MN_opPLUS}, /* +++ */
	{40, MN_opNEG}, /* --- */
};

static const char *OPNAME[] = {
	"not",
	"exists",
	"to",
	"until",
	"is?",
	"<:",
	"in?",
	"==",
	"!=",
	"<",
	"<=",
	">",
	">=",
	"|",
	"^",
	"&",
	"+",
	"-",
	"/",
	"%",
	"*",
	"<<",
	">>",
	"~",
	"++",
	"--",
	"..",
	"&&&",
	"***",
	"+++",
	"---",
};

int TT_priority(knh_term_t tt)
{
	if(TT_LET <= tt && tt <= TT_TSUB) {
		return OPDATA[tt-TT_LET].priority;
	}
	if(TT_ASIS <= tt && tt < TT_ERR) {
		return 99;
	}
	return 0;
}

knh_methodn_t TT_toMN(knh_term_t tt)
{
	if(TT_LET <= tt && tt <= TT_TSUB) {
		return OPDATA[tt - TT_LET].mn;
	}
	return MN_NONAME;
}

const char* knh_getopname(knh_methodn_t mn)
{
	DBG_ASSERT(mn + TT_NOT <= TT_TSUB);
	return OPNAME[mn];
}

#endif/*K_USING_LOADDATA*/

